<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Robot Telemetry Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="//cdn.jsdelivr.net/npm/protobufjs@7.X.X/dist/protobuf.min.js"></script>
</head>
<body>
    <div id="info">Waiting for Telemetry...</div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);
        // Position camera to look into the room from slightly above/outside
        camera.position.set(2, 2, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.5, 0); // Look at center of room volume
        controls.update();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(2, 5, 2);
        scene.add(dirLight);

        // --- 2. Geometry ---
        
        // The Cube (Robot) - 10cm = 0.1m
        const cubeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        // Initial position (center of floor)
        cube.position.set(0, 0.05, 0); 
        scene.add(cube);

        // The Room - 5m x 5m x 3m (height arbitrary, usually rooms are ~2.5-3m)
        // We use BackSide so we see the interior when outside, but walls disappear if we go "behind" them
        const roomSize = 5;
        const roomHeight = 3;
        const roomGeometry = new THREE.BoxGeometry(roomSize, roomHeight, roomSize);
        const roomMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x888888, 
            side: THREE.BackSide, // Only render inside faces
            wireframe: false
        });
        const room = new THREE.Mesh(roomGeometry, roomMaterial);
        // Shift room up so floor is at y=0
        room.position.set(0, roomHeight / 2, 0);
        scene.add(room);

        // Grid Helper for context
        const gridHelper = new THREE.GridHelper(5, 10);
        scene.add(gridHelper);

        // --- 3. ProtoBuf & Websocket Setup ---

        // Define the Proto schema inline for simplicity. 
        // In a real app, you might load this from a .proto file.
        const protoDefinition = `
            syntax = "proto3";

            message Vector3 {
                float x = 1;
                float y = 2;
                float z = 3;
            }

            message PositionEstimate {
                Vector3 gantry_position = 1;
                // other fields ignored...
            }

            message TelemetryBatchUpdate {
                PositionEstimate position_estimate = 1;
                // other fields like motor_status, etc. ignored...
            }
        `;

        // Parse schema
        const root = protobuf.parse(protoDefinition).root;
        const TelemetryBatchUpdate = root.lookupType("TelemetryBatchUpdate");

        // Websocket Connection
        const wsUrl = 'ws://localhost:8080/telemetry/53a7d9d4-30a2-4410-8601-55274076dffa';
        let socket;
        const infoDiv = document.getElementById('info');

        function connect() {
            socket = new WebSocket(wsUrl);
            socket.binaryType = 'arraybuffer'; // Important for Protobuf

            socket.onopen = () => {
                console.log('Connected to ' + wsUrl);
                infoDiv.innerText = 'Connected via Websocket';
                infoDiv.style.color = '#00ff00';
            };

            socket.onmessage = (event) => {
                try {
                    // event.data is an ArrayBuffer
                    const buffer = new Uint8Array(event.data);
                    
                    // Decode message
                    const message = TelemetryBatchUpdate.decode(buffer);
                    
                    // Check if PositionEstimate exists
                    if (message.positionEstimate && message.positionEstimate.gantryPosition) {
                        const pos = message.positionEstimate.gantryPosition;
                        
                        // Update Cube Position
                        // Ensure we map coordinates correctly (Robot coord system -> ThreeJS coord system)
                        // Assuming standard: Z-up in robotics? Y-up in ThreeJS?
                        // Common Robotics: X=Forward, Y=Left, Z=Up
                        // ThreeJS: X=Right, Y=Up, Z=Backward (Right-hand rule)
                        
                        // For this example, I will map directly: x->x, y->y, z->z
                        // Adjust lines below if your coordinate systems differ.
                        cube.position.set(pos.x || 0, pos.y || 0, pos.z || 0);
                    }
                } catch (err) {
                    console.error('Error decoding message:', err);
                }
            };

            socket.onclose = () => {
                console.log('Disconnected. Retrying in 2s...');
                infoDiv.innerText = 'Disconnected. Retrying...';
                infoDiv.style.color = 'orange';
                setTimeout(connect, 2000);
            };

            socket.onerror = (err) => {
                console.error('Socket error:', err);
            };
        }

        connect();

        // --- 4. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>