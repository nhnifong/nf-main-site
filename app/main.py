import os
import logging
from typing import Optional

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Depends, Header
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from .telemetry_manager import telemetry_manager
from .auth import verify_google_token, validate_stream_auth, check_robot_ownership
from .queue_manager import queue_manager

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Neufangled Control Plane",
    openapi_url=None,
    docs_url=None, 
    redoc_url=None,
)

# TODO explain what the hell this is.
# CORS is vital for the frontend to communicate with this backend from a browser
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, restrict this to your domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- STATIC FILE SERVING ---

# Define where the static files live in the container
FRONTEND_DIST = "nf-viz/dist"

# Mount the docs (MkDocs output)
# 'html=True' makes /docs/install/ serve /docs/install/index.html automatically.
app.mount("/docs", StaticFiles(directory=f"{FRONTEND_DIST}/docs", html=True), name="docs")

# Mount Assets (Only needed for local dev, in prod all image elements point to absolute bucket urls)
# We use a conditional check so we don't need these files in the production container
ASSETS_PATH = f"{FRONTEND_DIST}/assets"
if os.path.exists(ASSETS_PATH):
    app.mount("/assets", StaticFiles(directory=ASSETS_PATH), name="assets")

# Serve the HTML files vite has processed
@app.get("/")
async def read_index():
    return FileResponse(f"{FRONTEND_DIST}/index.html")

@app.get("/{page_name}")
async def read_page(page_name: str):
    # Mapping routes to specific HTML files generated by Vite
    page_map = {
        "control_panel": "playroom.html",
        "playroom": "playroom.html",
        "stringman-pilot": "stringman-pilot.html",
        "stringman-arpeggio-pilot": "stringman-arpeggio-pilot.html",
        "company": "company.html",
        "future": "future.html"
    }
    
    if page_name in page_map:
        return FileResponse(f"{FRONTEND_DIST}/{page_map[page_name]}")
    
    # If it's not a known page, let it 404 or return index for SPA behavior
    # Check if the file exists to prevent a crash if the file is missing
    path = f"{FRONTEND_DIST}/{page_name}.html"
    if os.path.exists(path):
         return FileResponse(path)
         
    raise HTTPException(status_code=404, detail="Page not found")

# --- Data Models for API Requests ---

class StreamAuthRequest(BaseModel):
    """Payload sent by MediaMTX to validate a stream publisher or reader."""
    ip: str
    user: str
    password: str  # MediaMTX can pass a token here
    path: str
    protocol: str
    id: str
    action: str
    query: str

# --- HTTP Endpoints ---

@app.on_event("startup")
async def startup_event():
    # Initialize Redis connections in the managers
    await telemetry_manager.connect()
    # await queue_manager.connect()
    pass

@app.post("/internal/auth")
async def media_server_auth(req: StreamAuthRequest):
    """
    Webhook called by MediaMTX.
    Returns 200 OK to allow, 401/403 to deny.
    
    - If action == 'publish', the Robot is trying to stream video.
      We verify the robot has permission to publish
    - If action == 'read', a User is trying to watch via WebRTC.
      We verify the user has permission to view this robot.
    """            
    is_valid = await validate_stream_auth(req, telemetry_manager.decoding_redis)
    if not is_valid:
        raise HTTPException(status_code=403, detail="Forbidden")
    return {"status": "OK"}

# --- Robot Control Endpoint ---

@app.websocket("/telemetry/{robot_id}")
async def websocket_endpoint(
    websocket: WebSocket, 
    robot_id: str,
    token: Optional[str] = None
):
    """
    Endpoint where observer.py connects to send telemetry and receive control messages.
    
   - Register as the 'source of truth' for this robot_id.
   - Subscribe to 'commands:{robot_id}' Redis channel to forward to hardware.
    """
    await websocket.accept()
    
    try:        
        logger.info(f"Robot {robot_id} connected via WebSocket")
        await telemetry_manager.handle_robot_connection(websocket, robot_id)

    except WebSocketDisconnect:
        logger.info(f"Robot {robot_id} disconnected from server")
        await telemetry_manager.disconnect(robot_id, "robot")
        
    except Exception as e:
        logger.error(f"WebSocket Error: {e}")
        await websocket.close(code=1011)
        raise e # raise so trace can be seen in logs

# --- User Interface for robot Endpoint ---

@app.websocket("/control/{robot_id}")
async def websocket_endpoint(
    websocket: WebSocket, 
    robot_id: str,
    token: Optional[str] = None
):
    """
    Endpoint where web based robot ui connects to send controls and receive telemetry messages.
       - Subscribe to 'state:{robot_id}' Redis channel to get updates.
       - If Playroom: Check Queue Manager. If Driver, allow writes to 'commands:{robot_id}'.
    """
    await websocket.accept()
    
    try:
        if not token:
            await websocket.close(code=1008) # code for Policy Violation
            # no token provided
            return

        # Verify Identity
        user_token = await verify_google_token(token)
        user_id = user_token["uid"]
        
        # Check Authorization
        # does the logged in user have permission to
        # 1. observe the robot?
        # 2. issue target or motion commands?
        # 3. issue calibration or shutdown commands?
        # For now, it's just all or nothing. 
        if not await check_robot_ownership(user_token, robot_id):
            await websocket.close(code=1008) # code for Policy Violation
            return

        logger.info(f"User {user_id} authorized for robot {robot_id}")
        await telemetry_manager.handle_user_connection(websocket, robot_id, user_id)

    except WebSocketDisconnect:
        logger.info(f"Client disconnected from {robot_id}")
        # Cleanup is handled within telemetry_manager, but specific disconnect logic goes here
        await telemetry_manager.disconnect(robot_id, "user")
        
    except Exception as e:
        logger.error(f"WebSocket Error: {e}")
        await websocket.close(code=1011)
        raise e # raise so trace can be seen in logs